###############################################################################
# This file (deps.in) is included by the toplevel makefile template
###############################################################################
#
# FIXME: move package dependencies to packages
#

# compilation/install output will be teed to here

# Let e.g. SAGE_ROOT/spkg/install pass options to sage-spkg, i.e. currently
# "-f", to force rebuilding dependent packages during an upgrade (#9896).
#
# When upgrading from a 4.x version of Sage, the script "sage-spkg" will be
# found in SAGE_ROOT/local/bin until the new sage_root repo is installed.
# After that, it will be found in SAGE_ROOT/spkg/bin
# (SAGE_ROOT/spkg/bin is added to the PATH in spkg/install).
# Therefore, do not put an explicit path for sage-spkg here.
SAGE_SPKG = sage-spkg $${SAGE_SPKG_OPTS}

# Tell make not to look for files with these names:
.PHONY: all all-sage base toolchain toolchain-deps

# Make the 4 build phases: base, toolchain, toolchain-deps, all-sage
# During the toolchain build, we export SAGE_BUILD_TOOLCHAIN=yes
# such that packages can do different things when they are built
# as prerequisite of GCC.
all-old:
	$(MAKE) base # FIXME: isnt base a part of toolchain?
	env SAGE_BUILD_TOOLCHAIN=yes $(MAKE) toolchain
	$(MAKE) toolchain-deps # actually reverse deps?
	$(MAKE) all-sage

# Base packages
# FP_prereq = $(call newest_version_base,prereq)

# Usage: newest_version_base $pkg
# Print version number of latest (according to modification time)
# base package $pkg
# As a fallback, we also look at the latest installed package.
define newest_version_base
$(shell \
    PKG="$(1)";\
    for FILE in `{ ls -1t @abs_top_srcdir@/build/base/$$PKG-*-install; ls -1t installed/$$PKG-*; } 2>/dev/null`;\
    do\
        ANS=`echo "$$FILE" | sed 's|.*/||; s|-install||'`;\
        if test -n "$$ANS"; then\
            echo "$$ANS";\
            exit 0;\
        fi;\
    done;\
    echo >&2 "Cannot determine latest version of $$PKG.";\
    echo "$$PKG"; )
endef

# Standard foreign package versions
@FP_VERSIONS@

# All targets except for the base packages
# ... generate from configure.ac.

scripts: $(BIN)

all-local: $(FOREIGN_DEP)

# nonsense? no. but not needed. covered by sagelib spkg
#     $(BIN) \
#     $(SAGE) \
#     $(CSAGE) \
#     $(EXTCODE)

# toolchain is a virtual "package"
TOOLCHAIN = $(INST)/toolchain

# we need gcc (if enabled) to build it.
$(INST)/toolchain: @DEP_gcc@
	echo @abs_top_builddir@/$(INST) > $@

toolchain: $(TOOLCHAIN)

# note on $(DEP_gcc_maybe)
# set
# DEP_gcc_maybe = @DEP_gcc@
# if you want *all* packages to rebuild upon gcc-upgrade

# Build all packages that GCC links against serially, otherwise this
# leads to race conditions where some library which is used by GCC gets
# reinstalled. Since system GCCs might use Sage's libraries, we do this
# unconditionally. We still use the dependency checking from $(MAKE),
# so this will not trigger useless rebuilds.
# See http://trac.sagemath.org/sage_trac/ticket/14168
# FIXME, serial rule! ouch. these are toolchain *reverse* deps
toolchain-deps:
	test -n @DEP_zlib@ && $(MAKE) @DEP_zlib@
	test -n @DEP_mpir@ && $(MAKE) @DEP_mpir@
	test -n @DEP_mpfr@ && $(MAKE) @DEP_mpfr@
	test -n @DEP_mpc@ && $(MAKE) @DEP_mpc@

# toolchain deps
# this is tricky, the first toolchain build does not need to be serialized...
# hmmm
$(INST)/toolchain_$(FP_ppl): $(INST)/toolchain_$(FP_mpir)
$(INST)/toolchain_$(FP_mpc): $(INST)/toolchain_$(FP_mpir)
$(INST)/toolchain_$(FP_mpc): $(INST)/toolchain_$(FP_mpfr)
$(INST)/toolchain_$(FP_mpfr): $(INST)/toolchain_$(FP_mpir)

# Everything needed to start up Sage using "./sage".  Of course, not
# every part of Sage will work.  It does not include Maxima for example.
SAGERUNTIME = @DEP_sagelib@ src/sage-stage-stamp

# hmm this might be a temporary kludge
sagelib_DEPS = $(CORE_MODULES:%=%-configure-stamp)

sagelib_DEPS+= @DEP_sagenb@ @DEP_ipython@ @DEP_gap@ $(DEP_gcc_maybe)

###############################################################################
# Building the base system
# FIXME: this wont work properly
#
# This consists of packages which are required for the Sage build system
# but not for Sage itself.  Since nothing explicitly depends on these,
# an update of these packages will not trigger a rebuild of every other
# package during an upgrade, see #13415.
###############################################################################
base: @DEP_bzip2@ @DEP_patch@

# If we are upgrading from a version 4.x of Sage, don't build bzip2.
# This is because the old sage-spkg script cannot install the new bzip2
# spkg (which is gzip compressed).  We continue using the old bzip2
# installation (which is version 1.0.5 since sage-3.3), which is fine.
bzip2):

patch_DEPS = @DEP_bzip2@

###############################################################################
# normal packages dependencies
###############################################################################
atlas_DEPS = @DEP_lapack@ @DEP_python@ $(DEP_gcc_maybe)

# HACK?
$(INST)/$(FP_atlas): upstream/lapack-3.4.2.tar

blas_DEPS = $(DEP_gcc_maybe)
blas_OODEPS = $(TOOLCHAIN)

cephes_DEPS = @DEP_cython@

boehm_gc_DEPS = $(DEP_gcc_maybe)
boehm_gc_OODEPS = $(TOOLCHAIN)

cliquer_DEPS = $(DEP_gcc_maybe)
cliquer_OODEPS = $(TOOLCHAIN)

cddlib_DEPS = @DEP_mpir@
cddlib_OODEPS = $(TOOLCHAIN)

# CONWAY depends on SAGERUNTIME because it runs Sage code to
# generate a Sage object (.sobj). FIXME: use juliens build
conway_polynomials_DEPS = $(SAGERUNTIME)

cvxopt_DEPS = \
    @DEP_lapack@ @DEP_blas@ @DEP_numpy@ \
    @DEP_atlas@ @DEP_cephes@ @DEP_gsl@ \
    @DEP_glpk@ $(DEP_gcc_maybe)
cvxopt_OODEPS = $(TOOLCHAIN)

# matplotlib is needed to test cvxopt (i.e., if SAGE_CHECK=yes). See #12742.
cvxopt_DEPS+= $(if filter($(SAGE_CHECK),yes),$(INST)/$(FP_matplotlib))

docutils_DEPS = @DEP_python@ $(DEP_gcc_maybe)
docutils_OODEPS = $(TOOLCHAIN)

elliptic_curves_DEPS = @DEP_python@ @DEP_sqlite@ $(DEP_gcc_maybe)
elliptic_curves_OODEPS = $(TOOLCHAIN)

eclib_DEPS = @DEP_mpir@ @DEP_pari@ @DEP_ntl@ $(DEP_gcc_maybe)
eclib_OODEPS = $(TOOLCHAIN)

ecm_DEPS = @DEP_mpir@ $(DEP_gcc_maybe)
ecm_OODEPS = $(TOOLCHAIN)

fflas_ffpack_DEPS = @DEP_mpir@ @DEP_givaro@ @DEP_gsl@ @DEP_atlas@ $(DEP_gcc_maybe)
fflas_ffpack_OODEPS = $(TOOLCHAIN)

freetype_OODEPS = $(TOOLCHAIN)

gap_DEPS = @DEP_termcap@ @DEP_readline@ @DEP_mpir@ $(DEP_gcc_maybe)
gap_OODEPS = $(TOOLCHAIN)

genus2reduction_DEPS = @DEP_pari@

# git_DEPS = @DEP_zlib@ @DEP_python@

gd_DEPS = @DEP_libpng@ @DEP_freetype@ @DEP_iconv@ $(DEP_gcc_maybe)
gd_OODEPS = $(TOOLCHAIN)

gdmodule_DEPS = @DEP_python@ @DEP_gd@ @DEP_iconv@ $(DEP_gcc_maybe)
gdmodule_OODEPS = $(TOOLCHAIN)

givaro_DEPS = @DEP_mpir@
givaro_OODEPS = $(TOOLCHAIN)

glpk_DEPS = @DEP_mpir@ @DEP_zlib@ $(DEP_gcc_maybe)
glpk_OODEPS = $(TOOLCHAIN)

gf2x_OODEPS = $(TOOLCHAIN)

gfan_DEPS = @DEP_mpir@ @DEP_cddlib@ $(DEP_gcc_maybe)
gfan_OODEPS = $(TOOLCHAIN)

gsl_DEPS = @DEP_atlas@ $(DEP_gcc_maybe)
gsl_OODEPS = $(TOOLCHAIN)

lcalc_DEPS = @DEP_pari@ @DEP_mpfr@ $(DEP_gcc_maybe)
lcalc_OODEPS = $(TOOLCHAIN)

ipython_DEPS = @DEP_python@ $(DEP_gcc_maybe)
ipython_OODEPS = $(TOOLCHAIN)

iml_DEPS = @DEP_mpir@ @DEP_gsl@ @DEP_atlas@ $(DEP_gcc_maybe)
iml_OODEPS = $(TOOLCHAIN)

jmol_DEPS = @DEP_sagenb@

lapack_DEPS = $(DEP_gcc_maybe)
lapack_OODEPS = $(TOOLCHAIN)

libgap_DEPS = @DEP_gap@ $(DEP_gcc_maybe)
libgap_OODEPS = $(TOOLCHAIN)

linbox_DEPS = @DEP_mpir@ @DEP_ntl@ @DEP_givaro@ \
              @DEP_mpfr@ @DEP_libfplll@ @DEP_iml@ \
              @DEP_libm4ri@ @DEP_libm4rie@ @DEP_fflas_ffpack@ \
              $(DEP_gcc_maybe)
linbox_OODEPS = $(TOOLCHAIN)

libpng_DEPS = @DEP_zlib@ $(DEP_gcc_maybe)
libpng_OODEPS = $(TOOLCHAIN)

libfplll_DEPS = @DEP_mpir@ @DEP_mpfr@ $(DEP_gcc_maybe)
libfplll_OODEPS = $(TOOLCHAIN)

lrcalc_OODEPS = $(TOOLCHAIN)

mpmath_DEPS = @DEP_python@

matplotlib_DEPS = \
    @DEP_python@ @DEP_numpy@ @DEP_freetype@ @DEP_libpng@ \
    @DEP_gdmodule@ $(DEP_gcc_maybe)
matplotlib_OODEPS = $(TOOLCHAIN)

mpir_DEPS = @DEP_iconv@ @DEP_gcc@

mpc_DEPS = @DEP_mpir@ @DEP_mpfr@ @DEP_gcc@

mpfr_DEPS = @DEP_mpir@ @DEP_gcc@

mpfi_DEPS = @DEP_mpir@ @DEP_mpfr@ $(DEP_gcc_maybe)
mpfi_OODEPS = $(TOOLCHAIN)

networkx_DEPS = @DEP_python@

ntl_DEPS = @DEP_mpir@ @DEP_gf2x@ $(DEP_gcc_maybe)
ntl_OODEPS = $(TOOLCHAIN)

numpy_DEPS = @DEP_python@ @DEP_lapack@ @DEP_blas@ @DEP_atlas@ $(DEP_gcc_maybe)
numpy_OODEPS = $(TOOLCHAIN)

pari_DEPS = @DEP_readline@ @DEP_mpir@ $(DEP_gcc_maybe)
pari_OODEPS = $(TOOLCHAIN)

polybori_DEPS = @DEP_python@ @DEP_ipython@ @DEP_scons@ @DEP_boost_cropped@ \
                @DEP_libm4ri@ @DEP_gd@ $(DEP_gcc_maybe)
polybori_OODEPS = $(TOOLCHAIN)

polytopes_db_DEPS =

ppl_DEPS = @DEP_mpir@ $(DEP_gcc_maybe)
ppl_OODEPS = $(TOOLCHAIN)

# Python links against -lbz2.  Technically speaking, we should add
# BZIP2 as dependency here.  But we don't do that to avoid needless
# recompiles of Python when upgrading.  Since bzip2 is part of the
# "base" target, we are guaranteed anyway that some version of bzip2
# is present.
python_DEPS = @DEP_zlib@ @DEP_readline@ @DEP_sqlite@ @DEP_libpng@ $(DEP_gcc_maybe)

readline_DEPS = @DEP_termcap@ $(DEP_gcc_maybe)
readline_OODEPS = $(TOOLCHAIN)

pycrypto_DEPS = @DEP_python@ $(DEP_gcc_maybe)
pycrypto_OODEPS = $(TOOLCHAIN)

pil_DEPS = @DEP_python@ $(DEP_gcc_maybe)
pil_OODEPS = $(TOOLCHAIN)

pynac_DEPS = @DEP_python@

pexpect_DEPS = @DEP_python@ $(DEP_gcc_maybe)
pexpect_OODEPS = $(TOOLCHAIN)

scons_DEPS = @DEP_python@

rubiks_OODEPS = $(TOOLCHAIN)

scipy_DEPS = @DEP_lapack@ @DEP_blas@ @DEP_numpy@ $(DEP_gcc_maybe)
scipy_OODEPS = $(TOOLCHAIN)

sqlite_DEPS = @DEP_readline@ $(DEP_gcc_maybe)
sqlite_OODEPS = $(TOOLCHAIN)

# To build SageTeX, you just need Python, but to test (SAGE_CHECK=yes)
# SageTeX, you actually need to run sage, produce plots,...
sagetex_DEPS = @DEP_python@ $(SAGERUNTIME) @DEP_maxima@ @DEP_scipy@ \
               @DEP_matplotlib@ @DEP_pil@ @DEP_tachyon@ $(DEP_gcc_maybe)
sagetex_OODEPS = $(TOOLCHAIN)

setuptools_DEPS = @DEP_python@

singular_DEPS = @DEP_mpir@ @DEP_ntl@ @DEP_readline@ @DEP_mpfr@ $(DEP_gcc_maybe)
singular_OODEPS = $(TOOLCHAIN)

termcap_DEPS  = $(DEP_gcc_maybe)
termcap_OODEPS = $(TOOLCHAIN)

tachyon_DEPS = @DEP_libpng@ $(DEP_gcc_maybe)
tachyon_OODEPS = $(TOOLCHAIN)

ratpoints_DEPS = @DEP_mpir@ $(DEP_gcc_maybe)
ratpoints_OODEPS = $(TOOLCHAIN)

ecl_DEPS = @DEP_mpir@ @DEP_readline@ @DEP_boehm_gc@ $(DEP_gcc_maybe)
ecl_OODEPS = $(TOOLCHAIN)

maxima_DEPS = @DEP_ecl@ $(DEP_gcc_maybe)
maxima_OODEPS = $(TOOLCHAIN)

r_DEPS = @DEP_atlas@ @DEP_iconv@ @DEP_readline@ $(DEP_gcc_maybe)
r_OODEPS = $(TOOLCHAIN)

rpy2_DEPS = @DEP_python@ @DEP_r@ $(DEP_gcc_maybe)
rpy2_OODEPS = $(TOOLCHAIN)

sympy_DEPS = @DEP_python@ $(DEP_gcc_maybe)
sympy_OODEPS = $(TOOLCHAIN)

cython_DEPS = @DEP_python@ $(DEP_gcc_maybe)
cython_OODEPS = $(TOOLCHAIN)

flintqs_DEPS = @DEP_mpir@ $(DEP_gcc_maybe)
flintqs_OODEPS = $(TOOLCHAIN)

flint_DEPS = @DEP_mpir@ @DEP_mpfr@ @DEP_ntl@ $(DEP_gcc_maybe)
flint_OODEPS = $(TOOLCHAIN)

libm4ri_DEPS = @DEP_libpng@ $(DEP_gcc_maybe)
libm4ri_OODEPS = $(TOOLCHAIN)

libm4rie_DEPS = @DEP_libm4ri@ @DEP_givaro@ @DEP_ntl@ $(DEP_gcc_maybe)
libm4rie_OODEPS = $(TOOLCHAIN)

# zn_poly really does depend on Python, despite this is far from obvious.
# The 'configure' script in zn_poly calls Python to make a 'makefile'.
zn_poly_DEPS = @DEP_mpir@ @DEP_python@ $(DEP_gcc_maybe)
zn_poly_OODEPS = $(TOOLCHAIN)

sagenb_DEPS = @DEP_python@ @DEP_setuptools@ @DEP_pexpect@ \
              @DEP_jinja2@ @DEP_sphinx@ @DEP_docutils@
sagenb_DEPS+= @DEP_sphinx@

sqlalchemy_DEPS = @DEP_python@ @DEP_setuptools@

sphinx_DEPS = @DEP_python@ @DEP_setuptools@ @DEP_docutils@ \
              @DEP_jinja2@ @DEP_pygments@

jinja2_DEPS = @DEP_python@ @DEP_setuptools@ @DEP_docutils@
jinja2_DEPS+= @DEP_pygments@

palp_OODEPS = $(TOOLCHAIN)

symmetrica_OODEPS = $(TOOLCHAIN)

sympow_OODEPS = $(TOOLCHAIN)

pygments_DEPS = @DEP_python@ @DEP_setuptools@
pygments_DEPS+= @DEP_sqlalchemy@

# List all *build-time* dependencies of the Sage library.  These are,
# on the one hand, programs needed for the build/install process of the
# Sage library (e.g. JINJA2), and on the
# other hand all dependencies for Cython files (e.g. PARI, NTL, MPIR).
#
# WHY?! this way ./sage -sh fails until all of them have been compiled
scripts_DEPS = \
    @DEP_atlas@ \
    @DEP_cephes@ \
    @DEP_cliquer@ \
    @DEP_ecl@ \
    @DEP_eclib@ \
    @DEP_ecm@ \
    @DEP_flint@ \
    @DEP_libfplll@ \
    @DEP_gd@ \
    @DEP_givaro@ \
    @DEP_glpk@ \
    @DEP_gsl@ \
    @DEP_iml@ \
    @DEP_jinja2@ \
    @DEP_lcalc@ \
    @DEP_libgap@ \
    @DEP_libpng@ \
    @DEP_linbox@ \
    @DEP_libm4ri@ \
    @DEP_libm4rie@ \
    @DEP_mpc@ \
    @DEP_mpfi@ \
    @DEP_mpfr@ \
    @DEP_mpir@ \
    @DEP_ntl@ \
    @DEP_numpy@ \
    @DEP_pari@ \
    @DEP_polybori@ \
    @DEP_ppl@ \
    @DEP_pynac@ \
    @DEP_python@ \
    @DEP_ratpoints@ \
    @DEP_readline@ \
    @DEP_singular@ \
    @DEP_symmetrica@ \
    @DEP_zn_poly@

src/c_lib-configure-stamp: $(csage_DEPS)
src/bin-configure-stamp: $(scripts_DEPS)
src/sage-configure-stamp: @DEP_cython@ src/c_lib-configure-stamp \
                          @DEP_elliptic_curves@ \
                          @DEP_graphs@ \
                          @DEP_cython@ \
                          @DEP_polytopes_db@ \
                          $(scripts_DEPS) @DEP_libgap@ \
                          src/c_lib-build-stamp

extcode: $(EXTCODE_TARGETS)

zlib_DEPS = $(DEP_gcc_maybe)
zlib_OODEPS = $(TOOLCHAIN)

# lib_c
src/c_lib-configure-stamp: $(csage_DEPS)
csage_DEPS = @DEP_mpir@ @DEP_ntl@ @DEP_pari@ @DEP_polybori@ @DEP_pynac@ \
             @DEP_python@ $(scripts_DEPS)

#FIXME:
$(INST)/ccache: $(BASE) @DEP_zlib@
	+$(PIPE) "$(SAGE_SPKG) ccache 2>&1" "tee -a $(SAGE_LOGS)/ccache.log"
	touch $(INST)/ccache

# make gcc dependencies explicit.
gcc_OODEPS = \
    $(INST)/toolchain_$(FP_mpir) \
    $(INST)/toolchain_$(FP_mpfr) \
    $(INST)/toolchain_$(FP_mpc) \
    $(INST)/toolchain_$(FP_ppl) \
    $(INST)/toolchain_$(FP_zlib)

###############################################################################

# setuptools forgets to update easy-install.pth during parallel
# builds, so we build the relevant packages serially.
